# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

<#
Convert-Etl2Pcapng

A PowerShell wrapper for etl2pcapng, which converts packet captures 
in ETL format generated by ndiscap (the ETW provider in Windows that 
produces packet capture events) to pcapng format (readable by Wireshark).
#>

################
###          ###
###  PUBLIC  ###
###          ###
################

#region PUBLIC

# FUNCTION : Register-Etl2Pcapng
# PURPOSE  : Registers the ecript to ETL files  
function Register-Etl2Pcapng 
{
    <#
    .SYNOPSIS
        Adds a right-click menu option in Windows for etl2pcapng.
    .DESCRIPTION
        Registers a shell context menu item for Convert-Etl2Pcapng. Right-clicking on an ETL fill will show an option "Convert with etl2pcapng". This will execute Convert-Etl2Pcapng with default settings against the ETL file.
    .EXAMPLE
        Register-Etl2Pcapng

        Registers the "Convert with etl2pcapng" shell menu item.
    .NOTES
        Author: Microsoft Edge OS Networking Team and Microsoft CSS
        Please file issues on GitHub @ https://github.com/microsoft/Convert-Etl2Pcapng
    .LINK
        More projects               : https://github.com/topics/msftnet
        Windows Networking Blog     : https://blogs.technet.microsoft.com/networking/
    #>

    [CmdletBinding()]
    param (
        # Causes the explorer menu option, "Convert with etl2pcapng", to not exit the command prompt when complete and output Verbose logging.
        [switch]$UseVerbose,
        # Causes the explorer menu option, "Convert with etl2pcapng", to not exit the command prompt when complete and output Debug logging.
        [switch]$UseDebug,
        # Accepts the EULA at runtime and prevents the prompt to accept.
        [switch]$AcceptEULA
    )

    Write-Verbose "Register-Etl2Pcapng - Work! Work!"
    Write-Verbose "Convert-Etl2Pcapng: Using PowerShell Version $($PSVersionTable.PSVersion)"
    # test for Admin access
    Write-Verbose "Register-Etl2Pcapng - Test admin rights."
    if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) 
    {
        return (Write-Error "Register-Etl2Pcapng: Administrator rights are needed to execute this command. Please run PowerShell as Administrator and try again." -EA Stop)
    }

    # read settings.xml
    $script:settings = Get-E2PSettings

    # for some reason the first pass doesn't return a E2PSettings class, so we force the issue
    if ($settings -isnot [E2PSettings])
    {
        $settings = [E2PSettings]::new($settings)
    }

    Write-Verbose "Register-Etl2Pcapng - Settings:`n$($settings.ToString())"

    # EULA must be accepted to proceed
    # don't prompt if -AcceptEULA was set
    if ($AcceptEULA.IsPresent)
    {
        Write-Verbose "Register-Etl2Pcapng - Accepting EULA by parameter."
        $settings.SetEulaStatus($true)
        Set-E2PSettings $settings
    }
    # prompt if no -AcceptEULA and EULA in settings is set to false
    elseif ($settings.AcceptEULA -eq $false)
    {
        Write-Host @"
Privacy Notice and End User License Agreement (EULA)
This PowerShell module does not collect or upload data to Microsoft, third-parties, or Microsoft partners.

Tracking and other statistical website data may be collected by PowerShellGallery.com when the module is downloaded, and by Github.com when the etl2pcapng.zip file is downloaded or updated by the module during cmdlet execution.

By agreeing to the EULA you permit the Convert-Etl2Pcapng module to contact github.com to check, download, and extract etl2pcapng to this computer from github.com.

WARNING: You must accept the EULA to register Convert-Etl2Pcapng as a context menu item.

"@
    
        $c = 0
        do
        {
            $answer = Read-Host "[Y] Yes, I Agree `n[N] I do Not agree`nResponse"
            $c++
        } until ($answer -eq 'a' -or $answer -eq 'y' -or $answer -eq 'n' -or $c -gt 3)
        
        switch ($answer)
        {
            'y' 
            { 
                Write-Verbose "Register-Etl2Pcapng - Accepting EULA by user input."
                # need to write EULA and make sure the file is downloaded
                $settings.SetEulaStatus($true)
                Set-E2PSettings $settings
                break 
            }
            'n' { return $null }
            default { return (Write-Error "Failed to get a valid user response to the EULA." -EA Stop)}
        }
    }

    # make sure the module is installed, just in case
    Write-Verbose "Register-Etl2Pcapng: Verify this is running from the module."
    $isModFnd = Get-Module -ListAvailable Convert-ETL2PCAPNG -EA SilentlyContinue

    if (-NOT $isModFnd) {
        # is it running and not in the list for some reason (like during testing)?
        $isModFnd = Get-Module Convert-ETL2PCAPNG -EA SilentlyContinue

        if (-NOT $isModFnd)
        {
            return (Write-Error "This cannot be run outside of the Convert-ETL2PCAPNG module. Please install the Convert-ETL2PCAPNG module first:`n`nInstall-Module Convert-ELT2PCAPNG." -EA Stop)
        }
    }

    # create a PSDrive to HKEY_CLASSES_ROOT
    Write-Verbose "Register-Etl2Pcapng: Create PSDrive for HKEY_CLASSES_ROOT."
    if (-NOT (Get-PSDrive -Name HKCR -EA SilentlyContinue)) 
    {
        New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT -Scope Local | Out-Null
    }

    # remove existing Convert-Etl2Pcapng entries
    $rootPath = "HKCR:\SystemFileAssociations\.etl\shell\Convert-Etl2Pcapng"

    $isCE2PReg = Get-Item $rootPath -EA SilentlyContinue
    
    if ($isCE2PReg)
    {
        try 
        {
            Remove-Item $rootPath -Force -Recurse -EA Stop    
        }
        catch 
        {
            Write-Warning "Failed to cleanup older Convert-Etl2Pcapng registration. This is a non-terminating warning."
        }
    }

    # create the shell extension for etl2pcapng
    Write-Verbose "Register-Etl2Pcapng: Add the Convert-Etl2Pcapng app to HKCR:\SystemFileAssociations\.etl to prevent possible conflicts."

    if (-NOT (New-RegKey "$rootPath\Command" Directory)) { Write-Error "Could not create directory in SystemFileAssociations."; exit }

    # create the command
    Write-Verbose "Register-Etl2Pcapng - Configure Convert-Etl2Pcapng."
    if (-NOT (New-RegKey $rootPath -value "Convert with etl2pcapng")) { Write-Error "Could not write menu text." }

    # create Open With keys for better Win11 support
    $rootOpenWith = "HKCR:\.etl\OpenWithProgids"
    $progID = "Convert-Etl2Pcapng.etl"

    Write-Verbose "Register-Etl2Pcapng - Configure Convert-Etl2Pcapng for Open With menu."
    $isOpenWith = Get-Item $rootOpenWith -EA SilentlyContinue
    try 
    {
        # if the OpenWithProgids is not there then create it
        if (-NOT $isOpenWith)
        {
            New-Item $rootOpenWith -Force -EA Stop
        }

        # The set version will create or change, where new only creates, so use set.
        Set-ItemProperty -Path $rootOpenWith -Name $progID -Type String -Value '' -Force -EA Stop
        
    }
    catch 
    {
        Write-Error "Failed to create the Open With association to .etl: $_"
    }

    # discover the current shell since currentuser scope puts the module in different places in 7+ than 5.1.
    # powershell = Windows PowerShell 5.1
    # pwsh       = PowerShell 7+
    if ($host.Version.Major -eq 5)
    {
        Write-Verbose "Register-Etl2Pcapng - Detected Windows PowerShell."
        $cli = "powershell.exe"
    }
    else
    {
        Write-Verbose "Register-Etl2Pcapng - Detected PowerShell 7."
        $cli = "pwsh.exe"
    }

    # if this is Win11 then we can use Windows Terminal (wt)
    if ( [System.Environment]::OSVersion.Version.Build -ge 22000 )
    {    
        Write-Verbose "Register-Etl2Pcapng - Detected Windows 11. Using Windows Terminal as the base console."

        if ($UseVerbose) 
        {
            $cmd = "wt $cli -NoProfile -Command Convert-Etl2Pcapng '`"%1`"' -Pause -Verbose"
        }
        elseif ($UseDebug) 
        {
            $cmd = "wt $cli -NoProfile -Command Convert-Etl2Pcapng '`"%1`"' -Pause -Debug -Verbose"
        }
        else 
        {
            $cmd = "wt $cli -NoProfile -Command Convert-Etl2Pcapng '`"%1`"'"
        }
    }
    else
    {    
        Write-Verbose "Register-Etl2Pcapng - Detected pre-Windows 11. Using CMD as the base console."
        if ($UseVerbose) 
        {
            $cmd = "cmd /k $cli -NoProfile -NonInteractive -NoLogo -Command Convert-Etl2Pcapng '%1' -Verbose"
        }
        elseif ($UseDebug) 
        {
            $cmd = "cmd /k $cli -NoProfile -NonInteractive -NoLogo -Command Convert-Etl2Pcapng '%1' -Debug -Verbose"
        }
        else 
        {
            $cmd = "cmd /c $cli -NoProfile -NonInteractive -NoLogo -Command Convert-Etl2Pcapng '%1'"
        }
    }


    Write-Verbose "Register-Etl2Pcapng: Add Convert-ETL2PCAPNG command: $cmd"
    if (-NOT (New-RegKey "$rootPath\Command" -Value $cmd)) { Write-Error "Could not write command to registry."; exit }


    # create the progID key structure and add the command for the open with menu
    $rootProgID = "HKCR:\$progID\shell\Convert with etl2pcapng\command"
    try 
    {
        $null = New-Item $rootProgID -Force -EA Stop
        Set-ItemProperty -Path $rootProgID -Name '(Default)' -Type String -Value $cmd -Force -EA Stop
        Set-ItemProperty -Path "HKCR:\$progID\shell\Convert with etl2pcapng" -Name '(Default)' -Type String -Value "Convert with etl2pcapng" -Force -EA Stop
    }
    catch 
    {
        # remove the OpenWithProgids entry
        $null = Remove-ItemProperty -Path $rootOpenWith -Name $progID -Force -EA SilentlyContinue
        Write-Error "Failed to create the Open With app: $_"
    }
    
    # check for the ETL extenstion in HKCR, create if missing
    Write-Verbose "Register-Etl2Pcapng: Add the context item to .etl files."

    Write-Verbose "Register-Etl2Pcapng: Work complete!"
} #end Register-Etl2Pcapng


# FUNCTION : Unregister-Etl2Pcapng
# PURPOSE  : Unregisters the ecript to ETL files  
function Unregister-Etl2Pcapng 
{
    [CmdletBinding()]
    param()

    <#
    .SYNOPSIS
        Removes the right-click menu option in Windows for etl2pcapng.
    .DESCRIPTION
        Unregisters the shell context menu item for Convert-Etl2Pcapng. This will remove the option to right-click on an ETL file and select "Convert with etl2pcapng". 
    .EXAMPLE
        Unregister-Etl2Pcapng

        Unregisters the "Convert with etl2pcapng" menu item.
    .NOTES
        Author: Microsoft Edge OS Networking Team and Microsoft CSS
        Please file issues on GitHub @ https://github.com/microsoft/Convert-Etl2Pcapng
    .LINK
        More projects               : https://github.com/topics/msftnet
        Windows Networking Blog     : https://blogs.technet.microsoft.com/networking/
    #>

    Write-Verbose "Unregister-Etl2Pcapng: Work! Work!"
    Write-Verbose "Convert-Etl2Pcapng: Using PowerShell Version $($PSVersionTable.PSVersion)"
    # test for Admin access
    Write-Verbose "Unregister-Etl2Pcapng: Test admin rights."
    if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) 
    {
        Write-Error "Unregister-Etl2Pcapng: Administrator rights are needed to execute this command. Please run PowerShell as Administrator and try again."
        return $null
    }

    # create a PSDrive to HKEY_CLASSES_ROOT
    Write-Verbose "Unregister-Etl2Pcapng: Creating HKCR PSDrive."
    if (-NOT (Get-PSDrive -Name HKCR -EA SilentlyContinue)) 
    {
        New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT -Scope Local | Out-Null
    }

    # check if the original version was registered and remove its components
    # remove the Convert-ETL2PCAPNG HKCR key
    $test = Get-Item "HKCR:\Convert-Etl2Pcapng" -EA SilentlyContinue
    if ($test)
    {
        Write-Verbose "Unregister-Etl2Pcapng: Removing Convert-Etl2Pcapng HKCR app."
        Remove-Item "HKCR:\Convert-Etl2Pcapng" -Recurse -Force -EA SilentlyContinue
    }

    $isOld = Get-ItemProperty -LiteralPath "HKCR:\.etl" -Name '(Default)' -EA SilentlyContinue
    if ($isOld.'(default)' -eq 'Convert-Etl2Pcapng')
    {
        # remove the default to .etl, but don't delete it
        Write-Verbose "Unregister-Etl2Pcapng: Cleanup .etl extension option."
        Set-ItemProperty -LiteralPath "HKCR:\.etl" -Name '(Default)' -Value "" -Force -EA SilentlyContinue
    }

    $test = Get-ItemProperty -LiteralPath "HKCR:\.etl" -Name 'Convert-Etl2Pcapng' -EA SilentlyContinue
    if ( $test )
    {
        Remove-ItemProperty -LiteralPath "HKCR:\.etl" -Name 'Convert-Etl2Pcapng' -Force 
    }

    # remove the SystemFileAssociation
    $rootPath = "HKCR:\SystemFileAssociations\.etl\shell\Convert-Etl2Pcapng"
    $testNew = Get-Item $rootPath -EA SilentlyContinue

    if ($testNew)
    {
        try 
        {
            Remove-Item $rootPath -Recurse -Force -ErrorAction Stop    
        }
        catch 
        {
            Write-Error "Unregister-Etl2Pcapng: Failed to cleanup the SystemFileAssociations."
        }
        
    }
    

    # clean up the user folder
    Write-Verbose "Unregister-Etl2Pcapng: Cleaning up appDataPath directory."
    
    # read settings.xml
    $settings = Get-E2PSettings

    # for some reason the first pass doesn't return a E2PSettings class, so we force the issue
    if ($settings -isnot [E2PSettings])
    {
        $settings = [E2PSettings]::new($settings)
    }

    try 
    {
        # OneDrive safe delete process
        $isDirFnd = Get-Item "$($settings.appDataPath)\etl2pcapng" -EA SilentlyContinue

        # this should workaround the OneDrive bug
        if ($isDirFnd) { 
            # first delete all the files    
            $childs = Get-ChildItem -LiteralPath "$($isDirFnd.FullName)" -Recurse -Force -File
            foreach ($child in $childs) 
            {
                $child.Delete()
            }

            # now get the directories
            $childs = Get-ChildItem -LiteralPath "$($isDirFnd.FullName)" -Recurse -Force
            foreach ($child in $childs) 
            {
                $child.Delete()
            }

            # finally nuke the root dir
            $isDirFnd.Delete($true)
        }

        # removing the settings, too. It will regenerate again if needed.
        Remove-Item "$($settings.appDataPath)\settings.xml" -Force -EA SilentlyContinue 
    }
    catch 
    {
        Write-Error "Unregister-Etl2Pcapng: Failed to cleanup the LocalAppData: $($settings.appDataPath)"
    }
    
    Write-Verbose "Unregister-Etl2Pcapng: Work complete!"
} #end Unregister-Etl2Pcapng


# FUNCTION : Convert-Etl2Pcapng
# PURPOSE  : Executes ETL2PCAPNG 
function Convert-Etl2Pcapng 
{
    <#
    .SYNOPSIS
        ndiscap tracing is the built-in packet capture tool used in Windows. ETL files cannot be read by third-party tools like Wireshark. Etl2pcapng converts ndiscap packet captures to a format readable by Wireshark.
    .DESCRIPTION
        This script converts ndiscap packets in an ETL into a Wireshark readable pcapng file.
    .PARAMETER Path
        The path to the ETL file or path containing the ETL file(s). When a container/directory is provided the script will search the partent directory for ETL files to convert.
    .PARAMETER Out
        The output path for the files. This parameter is optional. By default the script saves to the same directory the ETL file is located in.
    .PARAMETER Recurse
        Searches through child containers/directories for ETL files. Only valid when Path is a directory.
    .EXAMPLE
        Convert-Etl2Pcapng -Path C:\traces -Out D:\temp -Recurse

        Searches through C:\traces and all child directories for ETL files. The converted PCAPNG files will be saved to D:\temp.
    .EXAMPLE
        Convert-LBFO2Set C:\traces

        Converts all ETL files in C:\traces, but not any child directories, for ETLs and saves the PCAPNG files to the same directory (C:\traces).
    .NOTES
        Author: Microsoft Edge OS Networking Team and Microsoft CSS
        Please file issues on GitHub @ https://github.com/microsoft/Convert-Etl2Pcapng
    .LINK
        More projects               : https://github.com/topics/msftnet
        Windows Networking Blog     : https://blogs.technet.microsoft.com/networking/
    #>

    [CmdletBinding(DefaultParameterSetName = 'LiteralPath')]
    param (
        # Path accepts a literal string path.
        [parameter( Position = 0,
            ParameterSetName = 'LiteralPath',
            HelpMessage = 'Enter one or more filenames as a string',
            ValueFromPipeline = $false )]
        [string]
        $Path,

        # PSPath accepts a FileSystemInfo object from cmdlets like Get-Item and Get-ChildItem. Accepts pipeline input.
        [parameter( Position = 0,
            ParameterSetName = 'Path',
            HelpMessage = 'Enter one or more filenames as a string',
            ValueFromPipeline = $true )]
        [System.IO.FileSystemInfo]
        $PSPath,

        # Alternate output directory.
        [parameter( Position = 1,
            ParameterSetName = 'Path',
            ValueFromPipeline = $false )]
        [parameter( Position = 1,
            ParameterSetName = 'LiteralPath',
            ValueFromPipeline = $false )]
        [string]
        $Out = $null,

        # Search for ETL files in child directories.
        [parameter( Mandatory = $false,
            ParameterSetName = 'Path',
            ValueFromPipeline = $false )]
        [parameter( Mandatory = $false,
            ParameterSetName = 'LiteralPath',
            ValueFromPipeline = $false )]
        [switch]
        $Recurse,

        # Accepts EULA and skips prompt.
        [parameter( Mandatory = $false,
            ParameterSetName = 'Path',
            ValueFromPipeline = $false )]
        [parameter( Mandatory = $false,
            ParameterSetName = 'LiteralPath',
            ValueFromPipeline = $false )]
        [switch]
        $AcceptEULA,

        # Pauses the function at the end of execution. Used primarily for debugging with the context meny created by Register-Etl2Pcapng.
        [parameter( Mandatory = $false,
            ParameterSetName = 'Path',
            ValueFromPipeline = $false )]
        [parameter( Mandatory = $false,
            ParameterSetName = 'LiteralPath',
            ValueFromPipeline = $false )]
        [switch]
        $Pause
    )


    Write-Verbose "Convert-Etl2Pcapng: Work! Work!"
    Write-Verbose "Convert-Etl2Pcapng: Using PowerShell Version $($PSVersionTable.PSVersion)"

    ### Validating paths and parameters ###
    # check the path param
    Write-Verbose "Convert-Etl2Pcapng: Validate Path."
    if ($PSPath -is [System.IO.FileSystemInfo]) 
    {
        $isPathFnd = $PSPath
    }
    else 
    {
        $isPathFnd = Get-Item "$Path" -EA SilentlyContinue    
    }
    
    # if a dir/container, then look for ETL files
    if ($isPathFnd) 
    {
        # is this a container/directory
        if ($isPathFnd.PSisContainer) 
        {
            Write-Verbose "Convert-Etl2Pcapng: Searching for ETL files in $($isPathFnd.FullName)."
            # look for ETL files
            if ($Recurse) 
            {
                Write-Verbose "Convert-Etl2Pcapng: Dir with child container recurse."
                [array]$etlFiles = Get-ChildItem $isPathFnd.FullName -Filter "*.etl" -Recurse -Force -ErrorAction SilentlyContinue
            }
            else 
            {
                Write-Verbose "Convert-Etl2Pcapng: Dir with no child containers."
                [array]$etlFiles = Get-ChildItem $isPathFnd.FullName -Filter "*.etl" -Force -ErrorAction SilentlyContinue
            }
        }
        elseif ($isPathFnd.Extension -eq ".etl") 
        {
            Write-Verbose "Convert-Etl2Pcapng: Single file."
            [array]$etlFiles = $isPathFnd
        }
    }

    # exit if no ETL file(s) found
    if (-NOT $etlFiles) 
    {
        if ($PSPath -is [System.IO.FileSystemInfo]) 
        {
            Write-Error "Convert-Etl2Pcapng: Failed to find a valid ETL file. Path: $($PSPath.FullName)"
        }
        else 
        {
            Write-Error "Convert-Etl2Pcapng: Failed to find a valid ETL file. Path: $Path"
        }
        return $null
    }

    # make sure $Out is a valid location
    if ($Out) 
    {
        Write-Verbose "Convert-Etl2Pcapng: Validate Out."

        if (-NOT (Test-Path $Out -IsValid)) 
        {
            Write-Error "Convert-Etl2Pcapng: The Out path is an invalid path. Out: $Out"
            return $null
        }

        # create the dir if it's not there
        $isOutFnd = Get-Item "$Out" -EA SilentlyContinue
        if (-NOT $isOutFnd) 
        {
            try {
                Write-Verbose "Convert-Etl2Pcapng: Creating output path $Out"
                New-Item "$Out" -ItemType Directory -Force -EA Stop | Out-Null
            }
            catch {
                Write-Error "Convert-Etl2Pcapng: Failed to create Out directory at $Out. Error: $($error[0].ToString())"
            }
        }
    }


    ### get the path to etl2pcapng.exe
    Write-Verbose "Convert-Etl2Pcapng: Getting for etl2pcapng location."
    try 
    {
        if ($AcceptEULA.IsPresent)
        {
            [string]$e2pPath = Update-Etl2Pcapng -AcceptEULA
        }
        else
        {
            [string]$e2pPath = Update-Etl2Pcapng
        }
        
    }
    catch 
    {
        return (Write-Error "Settings failure: $_" -EA Stop)
    }

    # validate etl2pcapng is actually there and strip out the parent dir
    if ($e2pPath) 
    {
        Write-Verbose "Convert-Etl2Pcapng: Received etl2pcapng location: '$e2pPath'"

        # need this to trim a mysterious leading space when etl2pcapng is first downloaded and extracted
        $e2pPath = $e2pPath.Trim(" ")

        Write-Verbose "Convert-Etl2Pcapng: Validating etl2pcapng location: '$e2pPath'"

        # putting this in a loop due to OneDrive delay shinanigans
        $c = 0
        do
        {
            Start-Sleep -m 250

            $isE2PFnd = Get-Item "$e2pPath" -EA SilentlyContinue
            Write-Verbose "Convert-Etl2Pcapng: Validated e2p path: $($isE2PFnd.FullName)"

            $c++
        } until ($isE2PFnd -or $c -ge 5)
        
        if ($isE2PFnd) {
            $e2pDir = $isE2PFnd.DirectoryName
        }
        else {
            Write-Error "Convert-Etl2Pcapng: Failed to locate etl2pcapng.exe."
            return $null
        }
    }
    else
    {
        return $null
    }

    #### Finally do the conversion work ####
    Write-Verbose "Convert-Etl2Pcapng: Starting ETL to PCAPNG conversion(s)."
    Push-Location $e2pDir
    foreach ($file in $etlFiles) 
    {
        if ($Out) 
        {
            Write-Verbose "Convert-Etl2Pcapng: Converting $($file.FullName) to $Out\$($file.BaseName).pcapng"
            .\etl2pcapng.exe "$($file.FullName)" "$Out\$($file.BaseName).pcapng"
        }
        else 
        {
            Write-Verbose "Convert-Etl2Pcapng: Converting $($file.FullName) to $($file.DirectoryName)\$($file.BaseName).pcapng"
            .\etl2pcapng.exe "$($file.FullName)" "$($file.DirectoryName)\$($file.BaseName).pcapng"
        }
    }
    Pop-Location

    Write-Verbose "Convert-Etl2Pcapng: Work complete!"

    if ($Pause.IsPresent)
    {
        $null = Read-Host "Press Enter to continue..."
    }
} #end Convert-Etl2Pcapng



# FUNCTION : Update-Etl2Pcapng
# PURPOSE  : Gets the newest version of ETL2PCAPNG  
function Update-Etl2Pcapng 
{
    [CmdletBinding()]
    param(
        [switch]$Force,
        [switch]$AcceptEULA
        )

    <# 
     # Check for etl2pcapng updates only once a week
     #
     # The last time an update was checked for is located
     # in the module directory under settings.xml.
     #
     # The -Force param causes an etl2pcapng update check regardless of the last date checked.
     #
     #>


    Write-Verbose "Update-Etl2Pcapng - Starting"

    # check if etlpcapng is already downloaded - do not use pwsh terney to maintain Windows PowerShell backwards compatibilty!
    if ([System.Environment]::Is64BitOperatingSystem) 
    {
        $arch = "x64"
    }
    else {
        $arch = "x86"    
    }

    Write-Verbose "Update-Etl2Pcapng - OS architecture is $arch."

    # read settings.xml
    $settings = Get-E2PSettings

    # for some reason the first pass doesn't return a E2PSettings class, so we force the issue
    if ($settings -isnot [E2PSettings])
    {
        $settings = [E2PSettings]::new($settings)
    }

    Write-Verbose "Update-Etl2Pcapng - Settings:`n`n$($settings | Format-List | Out-String)`n`nType: $($settings.GetType().ToString())"

    # store app data path in an easier to use var
    $here = $settings.appDataPath

    Write-Verbose "Update-Etl2Pcapng - Timestamps:`nCurrent date:`t$((Get-Date).Date)`nSettings date:`t$($settings.LastUpdate.Date)`n"


    # EULA prompt
    if ($AcceptEULA.IsPresent)
    {
        $settings.SetEulaStatus($true)
        Set-E2PSettings $settings
    }
    elseif ($settings.AcceptEULA -eq $false)
    {
        Write-Host @"
Privacy Notice and End User License Agreement (EULA)
This PowerShell module does not collect or upload data to Microsoft, third-parties, or Microsoft partners.

Tracking and other statistical website data may be collected by PowerShellGallery.com when the module is downloaded, and by Github.com when the etl2pcapng.zip file is downloaded or updated by the module during cmdlet execution.

By agreeing to the EULA you permit the Convert-Etl2Pcapng module to contact github.com to check, download, and extract etl2pcapng to this computer from github.com.

"@

        $c = 0
        do
        {
            $answer = Read-Host "[A] Agree and continue, do not prompt in the future`n[Y] Agree once, prompt again (not recommended when using automation)`n[N] I do not agree, please terminate the script`nResponse"
            $c++
        } until ($answer -eq 'a' -or $answer -eq 'y' -or $answer -eq 'n' -or $c -gt 3)
        
        switch ($answer)
        {
            'a' 
            { 
                $settings.SetEulaStatus($true)
                Set-E2PSettings $settings
                break 
            }
            'y' { break }
            'n' { return $null }
            default { return (Write-Error "Failed to get a valid user response to the EULA." -EA Stop)}
        }

    }


    # check for an update when -Force set or it's been 7 days since we last checked
    if ($Force -or ((Get-Date).Date.AddDays(-7) -gt $settings.LastUpdate.Date)) 
    {
        Write-Verbose "Update-Etl2Pcapng - Checking for an update to etl2pcapng."

        Write-Verbose "Update-Etl2Pcapng - Getting etl2pcapng releases from GitGub."        
        $repo = 'microsoft/etl2pcapng' 

        try
        {
            $latest = Find-GitReleaseLatest $repo -EA Stop            
        }
        catch
        {
            return (Write-Error "Failed to retrieve the latest release from repo: $repo" -EA Stop)
        }
        
        Write-Verbose "Update-Etl2Pcapng - The latest release is:`n`n$($latest | Format-Table | Out-String)"

        if ($latest.Version -gt $settings.CurrVersion) 
        {
            Write-Verbose "Update-Etl2Pcapng - Cleaning up existing files."
            # delete existing zip file
            $isZipFnd = Get-Item "$here\etl2pcapng.zip" -EA SilentlyContinue
            if ($isZipFnd) { Remove-Item "$here\etl2pcapng.zip" -Force | Out-Null }
            
            # make sure VC Redist is installed
            Write-Verbose "Update-Etl2Pcapng - Checking for Visual Studio C++ Redistribution install."

            <# 
            # vcdist no longer needed as of version 1.5.0
            #look for VS C++ 2015-2019
            $isVCRedistFnd = Find-E2PSoftware "Microsoft Visual C\+\+ 2015-2019 Redistributable \($arch\)"
            
            if (-NOT $isVCRedistFnd -and ()) 
            {
                if ($arch -eq "x64") 
                {
                    $URI = $settings.vcredist64Uri
                }
                else 
                {
                    $URI = $settings.vcredist32Uri
                }

                Write-Verbose "Update-Etl2Pcapng - Downloading Microsoft Visual C\+\+ 2015-2019 Redistributable from $URI`."

                # download vcredist
                try 
                {
                    $dl = Get-WebFile -Uri $URI -savePath "$here" -fileName "vcredist.exe" -EA Stop
                }
                catch 
                {
                    return (Write-Error "Update-Etl2Pcapng - Microsoft Visual C`+`+ 2015-2019 Redistributable `($arch`) is not installed and could not be downloaded. Please manually download and install from $URI before using etl2pcapng. Error: $_" -EA Stop)
                }

                # try to install vcredist
                try 
                {
                    Push-Location $here
                    Write-Verbose "Update-Etl2Pcapng - Installing Microsoft Visual C\+\+ 2015-2019 Redistributable."
                    .\vcredist.exe /install /quiet /log "$here\Install_vc_redist_2017_x64.log"
                }
                catch 
                {
                    return (Write-Error "Update-Etl2Pcapng - Failed to install Microsoft Visual C`+`+ 2015-2019 Redistributable `($arch`). Please download from $URI and install before continuing." -EA Stop)
                }
                finally
                {
                    # cleanup
                    Pop-Location
                    Start-Sleep 1
                    Remove-Item "$here\vcredist.exe" -Force -EA SilentlyContinue | Out-Null
                }

                # only cleanup the log file if the install succeeds and we don't need it
                Remove-Item "$here\Install*.log" -Force -EA SilentlyContinue | Out-Null
                Write-Verbose "Update-Etl2Pcapng - VC redist installed."
            }
            #>
            
            
            # remove the existing etl2pcapng
            $isDirFnd = Get-Item "$here\etl2pcapng" -EA SilentlyContinue

            ### There is a -Recurse bug here when using OneDrive sync'ed dirs.
            ### It is supposed to be fixed in pwsh 7, but it's not.
            ### This should not be an issue for production since this should be run from a %LocalAppData%, not OneDrive.
            ### https://github.com/PowerShell/PowerShell/issues/9461
            
            #Remove-Item $isDirFnd.FullName -Recurse -Force -EA SilentlyContinue | Out-Null 

            # this should workaround the OneDrive bug
            if ($isDirFnd) { 
                # first delete all the files    
                $childs = Get-ChildItem -LiteralPath "$($isDirFnd.FullName)" -Recurse -Force -File
                foreach ($child in $childs) 
                {
                    $child.Delete()
                }

                # now get the directories
                $childs = Get-ChildItem -LiteralPath "$($isDirFnd.FullName)" -Recurse -Force -Directory
                foreach ($child in $childs) 
                {
                    $child.Delete($true)
                }

                # finally nuke the root dir
                $isDirFnd.Delete($true)
            }

            Write-Verbose "Update-Etl2Pcapng - Downloading etl2pcapng"
            # grab the etl2pcapng tags page from GitHub
            try 
            {
                $e2pPath = Get-WebFile -Uri $latest.URL -savePath "$here" -fileName $latest.FileName -EA Stop
            }
            catch 
            {
                return (Write-Error "Update-Etl2Pcapng - Cannot reach the etl2pcapng GitHub page: $_" -EA Stop)
            }
        
			if($latest.FileName.EndsWith(".zip")) {
				# extract and overwrite
				Write-Verbose "Update-Etl2Pcapng - Extracting the etl2pcapng archive."
				try 
				{
					Expand-Archive "$e2pPath" $here -Force -EA Stop    
				}
				catch 
				{
					return (Write-Error "Update-Etl2Pcapng - Could not extract etl2pcapng. Error: $_" -EA Stop)
				}
				
				# cleanup the zip
				Write-Verbose "Update-Etl2Pcapng - Cleaning up the zip file."
				$isZipFnd = Get-Item "$e2pPath" -EA SilentlyContinue
				if ($isZipFnd) { Remove-Item "$e2pPath" -Force -EA SilentlyContinue | Out-Null }
			}
			else {
				Push-Location $here
				New-Item -Path "etl2pcapng\$arch" -ItemType Directory -EA SilentlyContinue -Force | Out-Null
				Move-Item $latest.FileName "etl2pcapng\$arch\$($latest.FileName)" -Force
				Pop-Location
			}
            # update the installed version
            [version]$version = $latest.Version
            Write-Verbose "Update-Etl2Pcapng - Updating version in settings to $($version.ToString())"
            $settings.SetCurrVersion($version)
        }

        # update Settings.LastUpdate
        $updateTime = ([datetime]::Now).ToUniversalTime()
        Write-Verbose "Update-Etl2Pcapng - Updating last update check in settings to $($updateTime.ToString())"
        $settings.SetLastUpdate($updateTime)
        
        Write-Verbose "Update-Etl2Pcapng - Saving E2P settings changes."
        Set-E2PSettings $settings
    }

    
    $isE2PFnd = Get-Item "$here\etl2pcapng\$arch\etl2pcapng.exe" -EA SilentlyContinue

    
    if ($isE2PFnd) 
    {
        $fullPath = "$here\etl2pcapng\$arch\etl2pcapng.exe"
        Write-Verbose "Update-Etl2Pcapng - Returning etl2pcapng.exe at '$fullPath'"
        Write-Debug "Update-Etl2Pcapng - '$here'"
        Write-Verbose "Update-Etl2Pcapng - Work complete."
        return $fullPath
    }
    else 
    {
        Write-Verbose "Update-Etl2Pcapng - Failed to find or download etl2pcapng.exe."
        Write-Verbose "Update-Etl2Pcapng - Work complete."
        return $null    
    }

} #end Update-Etl2Pcapng

#endregion PUBLIC


#################
###           ###
###  PRIVATE  ###
###           ###
#################

#region AUX
##### AUX functions that are not exported #####

# FUNCTION : Get-E2PSettings
# PURPOSE  : Finds and returns the module settings  
function Get-E2PSettings 
{
    Write-Verbose "Get-E2PSettings - Begin"

    $setPath = "$(Find-E2PPath)\settings.xml"
    Write-Verbose "Get-E2PSettings - Using '$setPath' as the appDataPath."

    # is there a settings file at the appDataPath location?
    $isADP = Get-Item "$setPath" -ErrorAction SilentlyContinue

    # read the file if it exists
    if ($isADP) 
    {
        Write-Verbose "Get-E2PSettings - Settings file found. Getting settings from file."
        # read the settings file
        try 
        {
            $settings = [E2PSettings]::New((Import-Clixml "$setPath"))    
        }
        catch 
        {
            return (Write-Error "Failed to import settings: $_" -EA Stop)
        }
        

        # return the settings
        Write-Verbose "Get-E2PSettings - Work complete!"
        return $settings

    # create the file if it does not exist
    }
    else 
    {
        # create the etl2pcapng dir
        Write-Verbose "Get-E2PSettings - Settings file not found. Using defaults."
        $settings = New-E2PSetting

        # write the settings file
        Write-Verbose "Get-E2PSettings - Writing settings."
        Set-E2PSettings $settings
        
        # return settings
        Write-Verbose "Get-E2PSettings - Work complete!"
        return ([E2PSettings]::new($settings))
    }
    Write-Verbose "Get-E2PSettings - Something unexpected went wrong and no settings were returned."
    Write-Verbose "Get-E2PSettings - Work complete!"
    return $null
} #end Get-E2PSettings


# FUNCTION : Set-E2PSettings
# PURPOSE  : Updates E2P settings
function Set-E2PSettings
{
    [CmdletBinding()]
    param (
        [PSCustomObject]$settings
    )

    $isAPDFnd = Get-Item "$($settings.appDataPath)" -EA SilentlyContinue

    try 
    {
        if (-NOT $isAPDFnd)
        {
            New-Item -Path "$($settings.appDataPath)" -ItemType Directory -Force -EA Stop | Out-Null
        }

        $settings | Export-Clixml -Path "$($settings.appDataPath)\settings.xml" -Depth 10 -Force -EA Stop
    }
    catch 
    {
        return (Write-Error "Failed to write settings.xml to $($settings.appDataPath): $_" -EA Stop)
    }

    return $null
}


function New-E2PSetting
{
    [string]$here = Find-E2PPath

    # create default settings
    $defSettings = [E2PSettings]::New($here)
        
    return $defSettings
}


function Find-E2PPath
{
    Write-Verbose "Find-E2PPath - Begin."
    Write-Verbose "Find-E2PPath - Searching for installed module."
    # make sure the running module
    $mods = Get-Module Convert-Etl2Pcapng -EA SilentlyContinue

    # fall back to listed modules if none are running
    if (-NOT $mods)
    {
        $mods = Get-Module -ListAvailable Convert-Etl2Pcapng -EA SilentlyContinue
    }
    
    if ($mods)
    {
        Write-Verbose "Find-E2PPath - Figuring out what path to use."
        $here = $env:PSModulePath -split ';' | Where-Object { $_ -match "$([regex]::Escape("$env:USERPROFILE"))" }

        # use legacy %localappdata% method if CurrentUser is not available
        if (-NOT $here)
        {
            Write-Verbose "Find-E2PPath - Had to fall back to legacy %LOCALAPPDATA% path."
            # we avoid using admin module paths since I can't dynamnically add files there
            $here = "$env:LOCALAPPDATA\Convert-Etl2Pcapng"
        }
    }
    else 
    {
        return (Write-Error "This cannot be run outside of the Convert-ETL2PCAPNG module. Please install the Convert-ETL2PCAPNG module first:`n`nInstall-Module Convert-ELT2PCAPNG." -EA Stop)
    }

    if (-NOT $here)
    {
        return (Write-Error "Failed to find a current user module path." -EA Stop)
    }

    Write-Verbose "Find-E2PPath - Returning: '$here\Convert-Etl2Pcapng'"
    Write-Verbose "Find-E2PPath - End."
    return ("$here\Convert-Etl2Pcapng")
}


# FUNCTION: Get-WebFile
# PURPOSE:  
function Get-WebFile
{
    param ( 
        [string]$URI,
        [string]$savePath,
        [string]$fileName
    )

    Write-Verbose "Get-WebFile - Begin"
    Write-Verbose "Get-WebFile - Attempting to download: $dlUrl"

    # make sure we don't try to use an insecure SSL/TLS protocol when downloading files
    $secureProtocols = @() 
    $insecureProtocols = @( [System.Net.SecurityProtocolType]::SystemDefault, 
                            [System.Net.SecurityProtocolType]::Ssl3, 
                            [System.Net.SecurityProtocolType]::Tls, 
                            [System.Net.SecurityProtocolType]::Tls11) 
    foreach ($protocol in [System.Enum]::GetValues([System.Net.SecurityProtocolType])) 
    { 
        if ($insecureProtocols -notcontains $protocol) 
        { 
            $secureProtocols += $protocol 
        } 
    } 
    [System.Net.ServicePointManager]::SecurityProtocol = $secureProtocols

    try 
    {
        Invoke-WebRequest -Uri $URI -OutFile "$savePath\$fileName"
    } 
    catch 
    {
        return (Write-Error "Could not download $URI`: $($Error[0].ToString())" -EA Stop)
    }

    Write-Verbose "Get-WebFile - File saved to: $savePath\$fileName"
    Write-Verbose "Get-WebFile - End"
    return "$savePath\$fileName"
} #end Get-WebFile


# FUNCTION: Find-GitReleaseLatest
# PURPOSE:  Calls Github API to retrieve details about the latest release. Returns a PSCustomObject with repro, version (tag_name), and download URL.
function Find-GitReleaseLatest
{
    [CmdletBinding()]
    param(
        [string]$repo
    )

    Write-Verbose "Find-GitReleaseLatest - Begin"

    $baseApiUri = "https://api.github.com/repos/$($repo)/releases/latest"

    # make sure we don't try to use an insecure SSL/TLS protocol when downloading files
    $secureProtocols = @() 
    $insecureProtocols = @( [System.Net.SecurityProtocolType]::SystemDefault, 
                            [System.Net.SecurityProtocolType]::Ssl3, 
                            [System.Net.SecurityProtocolType]::Tls, 
                            [System.Net.SecurityProtocolType]::Tls11) 
    foreach ($protocol in [System.Enum]::GetValues([System.Net.SecurityProtocolType])) 
    { 
        if ($insecureProtocols -notcontains $protocol) 
        { 
            $secureProtocols += $protocol 
        } 
    } 
    [System.Net.ServicePointManager]::SecurityProtocol = $secureProtocols
    
    # get the available releases
    Write-Verbose "Find-GitReleaseLatest - Processing repro: $repo"
    Write-Verbose "Find-GitReleaseLatest - Making Github API call to: $baseApiUrl"
    try 
    {
        if ($pshost.Version.Major -le 5)
        {
            $rawReleases = Invoke-WebRequest $baseApiUri -UseBasicParsing -EA Stop
        }
        elseif ($pshost.Version.Major -ge 6)
        {
            $rawReleases = Invoke-WebRequest $baseApiUri -EA Stop
        }
        else 
        {
            return (Write-Error "Unsupported version of PowerShell...?" -EA Stop)
        }
    }
    catch 
    {
        return (Write-Error "Could not get GitHub releases. Error: $_" -EA Stop)        
    }

    Write-Verbose "Find-GitReleaseLatest - Processing results."
    try
    {
        [version]$version = ($rawReleases.Content | ConvertFrom-Json).tag_name.Trim("v")
    }
    catch
    {
        $version = ($rawReleases.Content | ConvertFrom-Json).tag_name
    }

    Write-Verbose "Find-GitReleaseLatest - Found version: $version"

    $dlURI = ($rawReleases.Content | ConvertFrom-Json).Assets.browser_download_url

    Write-Verbose "Find-GitReleaseLatest - Found download URL: $dlURI"
	$fileName = $dlURI.Split("/")[-1]
    Write-Verbose "Find-GitReleaseLatest - End"

    return ([PSCustomObject]@{
        Repo    = $repo
        Version = $version
        URL     = $dlURI
		FileName = $fileName
    })
} #end Find-GitReleaseLatest


# FUNCTION: Find-E2PSoftware
# PURPOSE:  Gets a list of all installed software from the registry with optional filter on the DisplayName.

function Find-E2PSoftware 
{
    [CmdletBinding()]
    param ($displayFilter = $null)

    Write-Verbose "Find-E2PSoftware - Begin"

    $apps = @()
    
    [string[]]$regPaths = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall", "HKLM:\SOFTWARE\Wow6432node\Microsoft\Windows\CurrentVersion\Uninstall"
      
    foreach ($regPath in $regPaths) 
    { 
      
        Write-Verbose "Find-E2PSoftware: Checking Path: $regPath"

        try 
        { 
            $reg = Get-Item $regPath -ErrorAction Stop
        }
        catch 
        { 
            Write-Debug "Find-E2PSoftware: Could not find the path: $_ `n`n $reg "
            continue 
        } 
      

        # change the EAP to stop to force the try to fail if there is an error
        $ErrorActionPreference = "SilentlyContinue"

        # get all the child keys
        [array]$regkeys = Get-ChildItem $regPath

        #echo "$($regKeys.PSChildName | Out-String)"
      
        foreach ($key in $regkeys) 
        {   
            Write-Verbose "Find-E2PSoftware: $($key.PSChildName)"
                
            if ($displayFilter) 
            {
                Write-Verbose "Find-E2PSoftware: Filter $((Get-ItemProperty -Path $key.PsPath -Name DisplayName).DisplayName) match $displayFilter"
                if ( "$((Get-ItemProperty -Path $key.PsPath -Name DisplayName).DisplayName)" -match $displayFilter) 
                {
                    # create the PsCustomObject that stores software details
                    $tmpObj = [pscustomobject]@{
                        Name = $key.PSChildName
                    }
        
                    # loop through all the properties and add them to the object
                    $key.Property | ForEach-Object {
                         
                        $tmpObj | Add-Member -Name $_ -MemberType NoteProperty -Value "$((Get-ItemProperty -Path $key.PsPath -Name $_)."$_")"
                    }
        
                    # add the software to the apps array
                    $apps += $tmpObj
                    Remove-Variable tmpObj
                }
            }
            else 
            {
                $tmpObj = [pscustomobject]@{
                    Name = $key.PSChildName
                }
    
                $key.Property | ForEach-Object {
                     
                    $tmpObj | Add-Member -Name $_ -MemberType NoteProperty -Value "$((Get-ItemProperty -Path $key.PsPath -Name $_)."$_")"
                }
    
                # add the software to the apps array
                $apps += $tmpObj
                Remove-Variable tmpObj
            }
        }
    }

    Write-Verbose "Find-E2PSoftware: Work complete!"
    return $apps     
} #end Find-E2PSoftware


class E2PSettings
{
    [datetime]$LastUpdate
    [version]$CurrVersion
    [string]$appDataPath
    [bool]$AcceptEULA

    #region construtors
    E2PSettings()
    {
        $this.LastUpdate    = [datetime]::FromFileTimeUtc(0)
        $this.CurrVersion   = [version]::new()
        $this.appDataPath   = $null
        $this.AcceptEULA    = $false
    }

    E2PSettings([string]$path)
    {
        $this.LastUpdate    = [datetime]::FromFileTimeUtc(0)
        $this.CurrVersion   = [version]::new()
        $this.appDataPath   = $path
        $this.AcceptEULA    = $false
    }

    E2PSettings([PSCustomObject]$set)
    {
        $this.LastUpdate    = $set.LastUpdate
        $this.CurrVersion   = $set.CurrVersion
        $this.appDataPath   = $set.appDataPath
        $this.AcceptEULA    = $set.AcceptEULA
    }
    #endregion construtors

    #region getters
    [datetime]GetLastUpdate()
    {
        return ($this.LastUpdate)
    }

    [version]GetCurrVersion()
    {
        return ($this.CurrVersion)
    }

    [string]GetAppDataPath()
    {
        return ($this.appDataPath)
    }

    [bool]GetEulaStatus()
    {
        return ($this.AcceptEULA)
    }
    #endregion getters


    #region setters
    SetLastUpdate([datetime]$LastUpdate)
    {
        if ($null -ne $LastUpdate)
        {
            $this.LastUpdate = $LastUpdate
        }
    }

    SetCurrVersion([version]$CurrVersion)
    {
        if ($null -ne $CurrVersion)
        {
            $this.CurrVersion = $CurrVersion
        }
    }

    SetAppDataPath([string]$appDataPath)
    {
        if ($null -ne $appDataPath)
        {
            $this.appDataPath = $appDataPath
        }
    }

    SetEulaStatus([bool]$eulaStatus)
    {
        $this.AcceptEULA = $eulaStatus
    }
    #endregion setters


    #region methods
    [string]ToString()
    {
        return (@"
LastUpdate  : $($this.appDataPath)
CurrVersion : $($this.CurrVersion)
appDataPath : $($this.appDataPath)
AcceptEULA  : $($this.AcceptEULA)
"@)
    }

    # by returning an ErrorRecord the Save method can create a terminating error in a caller using a try-catch
    [System.Management.Automation.ErrorRecord]
    Save($Filename)
    {
        # convert the filename to a string if we get a filesystem object from something like Get-Item
        if ($Filename -is [System.IO.FileSystemInfo])
        {
            $Filename = $Filename.Fullname
        }

        # make sure the file is valid
        if (-NOT (Test-Path "$Filename" -IsValid))
        {
            # return a terminating error
            return (Write-Error "[E2PSettings].Save - The filename is invalid: $Filename" -EA Stop)
        }

        # no check if the file exists. This function explicitly overwrites the existing content

        try 
        {
            $this | Export-Clixml -Path "$Filename" -Depth 20 -Encoding utf8 -Force -EA Stop
        }
        catch 
        {
            # return a terminating error
            return (Write-Error "[E2PSettings].Save - Could not save the settings file: $_" -EA Stop)
        }

        # return a nonterminating null
        return $null
    }

    #endregion methods
}


function New-RegKey 
{
    [CmdletBinding()]
    param(
        [string]$path,
        [string]$type,
        $value
    )

    Write-Verbose "New-RegKey: Starting"
    # make sure the PSDrive to HKCR is created
    if (-NOT (Get-PSDrive -Name HKCR -EA SilentlyContinue)) 
    {
        New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT -Scope Local | Out-Null
    }

    # do the reg work
    try 
    {
        Write-Verbose "New-RegKey: Creating key $path"
        if ($type -eq "Directory") {
            New-Item "$path" -ItemType $type -Force -EA SilentlyContinue | Out-Null
        }
        else {
            Write-Verbose "New-RegKey: Setting property on $path to $value"
            Set-ItemProperty -LiteralPath $path -Name '(Default)' -Value $value -Force -EA SilentlyContinue | Out-Null
        }
    }
    catch 
    {
        Write-Error "New-RegKey: Failed to create $path."
        return $false
    }

    Write-Verbose "New-RegKey: Work complete!"
    return $true
}


#endregion AUX

# the list of functions the module will export.
Export-ModuleMember -Function Register-Etl2Pcapng
Export-ModuleMember -Function Unregister-Etl2Pcapng
Export-ModuleMember -Function Convert-Etl2Pcapng
Export-ModuleMember -Function Update-Etl2Pcapng
